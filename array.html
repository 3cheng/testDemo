<!DOCTYPE html>
<html>
    <head>
      <meta charset="utf-8">
      <title>
          数组使用
      </title>
      <link rel="stylesheet" type="text/css" href="common.css"/>
      <style type="text/css">
        .radio-list{
          font-size: 16px;
          text-align: left;
        }
        .radio-list input{
          width: 16px;
          height: 16px;
          cursor: pointer;
        }
        .panel {
          display: none;
        }
        .un-detail,.sort-detail {
          display: none;
          margin: 20px 0px;
        }
      </style>
      <script src="syntax_highlighter/brush.js" type="text/javascript"></script>
      <link rel="stylesheet" type="text/css" href="syntax_highlighter/shCore.css" />
      <link rel="stylesheet" type="text/css" href="syntax_highlighter/shThemeDefault.css" />
    </head>
    
    <body>
        <h3>数组用法</h3>
        <div class='btn-list' id="btnCont">
          <button id="uniqueBtn" class="radius-btn">数组去重</button>
          <button id="sortBtn" class="radius-btn">数组排序</button>
        </div>

        <div id="uniquePanel" class="panel">
          <p>数组去重</p>
          <p>原始数组： [4, 2, 5, 5, 8, 12, 43, 7, 2]</p>
          <div class="radio-list">
            <input type="radio" name="unique" data-id="r1"/>
            <label>遍历数组法</label>
            <input type="radio" name="unique" data-id="r2"/>
            <label>对象键值对法</label>
            <input type="radio" name="unique" data-id="r3"/>
            <label>数组下标判断法</label>
            <input type="radio" name="unique" data-id="r4"/>
            <label>排序后相邻去除法</label>
            <input type="radio" name="unique" data-id="r5" checked="checked" />
            <label>优化遍历数组法</label>
          </div>

          <div class="unique-details" id="unDetail">
            <div class="un-detail" id="r1">
              <strong>结果：</strong>
              <p id='r1-res'></p>
              <p>检测浏览器是否支持ECMA5</p>
              <pre class='brush: javascript'>
                // 判断浏览器是否indexOf (indexOf 为ecmaScript5新方法 IE8以下（包括IE8）只支持到ECMAScript3)
                if (!Array.prototype.indexOf){
                  // 新增indexOf方法
                  Array.prototype.indexOf = function(item){
                    var result = -1, a_item = null;
                    if (this.length == 0){
                      return result;
                    }
                    for(var i = 0, len = this.length; i < len; i++){
                      a_item = this[i];
                      if (a_item === item){
                        result = i;
                        break;
                      }  
                    }
                    return result;
                  }
                }
              </pre>
              <p>普通遍历数组法：</p>
              <pre class='brush: javascript'>
                // 最简单数组去重法
                function unique1(array){
                  var n = []; //一个新的临时数组
                  //遍历当前数组
                  for(var i = 0; i < array.length; i++){
                    //如果当前数组的第i已经保存进了临时数组，那么跳过，
                    //否则把当前项push到临时数组里面
                    if (n.indexOf(array[i]) == -1) n.push(array[i]);
                  }
                  return n;
                }
              </pre>
            </div>
            <div class="un-detail" id="r2">
              <strong>结果：</strong>
              <p id="r2-res"></p>
              <p>对象键值对法：</p>
              <pre class='brush: javascript'>
                // 速度最快， 占空间最多（空间换时间）
                function unique2(array){
                  var n = {}, r = [], len = array.length, val, type;
                    for (var i = 0; i < array.length; i++) {
                        val = array[i];
                        type = typeof val;
                        if (!n[val]) {
                            n[val] = [type];
                            r.push(val);
                        } else if (n[val].indexOf(type) < 0) {
                            n[val].push(type);
                            r.push(val);
                        }
                    }
                    return r;
                }
              </pre>
            </div>
            <div class="un-detail" id="r3">
              <strong>结果：</strong>
              <p id="r3-res"></p>
              <p>数组下标判断法</p>
              <pre class="brush:javascript">
                function unique3(array){
                  var n = [array[0]]; //结果数组
                  //从第二项开始遍历
                  for(var i = 1; i < array.length; i++) {
                    //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
                    //那么表示第i项是重复的，忽略掉。否则存入结果数组
                    if (array.indexOf(array[i]) == i) n.push(array[i]);
                  }
                  return n;
                }
              </pre>
            </div>
            <div class="un-detail" id="r4">
              <strong>结果：</strong>
              <p id="r4-res"></p>
              <p>排序后相邻去除法</p>
              <pre class="brush:javascript">
                // 将相同的值相邻，然后去除
                function unique4(array){
                  array.sort(); 
                  var re=[array[0]];
                  for(var i = 1; i < array.length; i++){
                    if( array[i] !== re[re.length-1])
                    {
                      re.push(array[i]);
                    }
                  }
                  return re;
                }
              </pre>
            </div>
            <div class="un-detail" id="r5">
              <strong>结果：</strong>
              <p id="r5-res"></p>
              <p>优化遍历数组法</p>
              <pre class="brush:javascript">
                // 思路：获取没重复的最右一值放入新数组
                function unique5(array){
                  var r = [];
                  for(var i = 0, l = array.length; i < l; i++) {
                    for(var j = i + 1; j < l; j++)
                      if (array[i] === array[j]) j = ++i;
                    r.push(array[i]);
                  }
                  return r;
                }
              </pre>
            </div>
          </div>

        </div>
        
        <div id="sortPanel" class="panel">
          <p>数组排序算法总结：<a href="http://jsdo.it/norahiko/oxIy/fullscreen" alt="jpan">日本人编写的排序动画</a></p>
          <p>原始数组： [8,2, 3, 55, 12, 20, 16, 18, 15, 20, 11, 7]</p>
          <div class="radio-list">
            <input type="radio" name="sort" data-id="s1"/>
            <label>插入排序</label>
            <input type="radio" name="sort" data-id="s2"/>
            <label>二分插入排序</label>
            <input type="radio" name="sort" data-id="s3"/>
            <label>希尔排序</label>
            <input type="radio" name="sort" data-id="s4"/>
            <label>冒泡排序</label>
            <input type="radio" name="sort" data-id="s5"/>
            <label>改进冒泡排序</label>
            <input type="radio" name="sort" checked="checked" data-id="s6" />
            <label>快速排序</label>
            <input type="radio" name="sort" data-id="s7"/>
            <label>选择排序</label>
            <input type="radio" name="sort" data-id="s8"/>
            <label>堆排序</label>
            <input type="radio" name="sort" data-id="s9"/>
            <label>归并排序</label>
          </div>

          <div class="sort-details" id="sortDetail">
            <div class="sort-detail" id="s1">
              <strong>结果：</strong>
              <p id="s1-res"></p>
              <p>原理图：</p>
              <img title="插入排序原理图" alt="插入排序原理图" src="images/sort1.png"/>
              <p>插入排序算法</p>
              <pre class="brush:javascript">
                // 插入排序 从下标1开始每增1项排序一次，越往后遍历次数越多
                function sort1(array) {
                  var len = array.length,
                      i, j, tmp, result;
                  
                  // 设置数组副本
                  result = array.slice(0);
                  for(i=1; i < len; i++){
                    tmp = result[i];
                    j = i - 1;
                    while(j>=0 && tmp < result[j]){
                      result[j+1] = result[j];
                      j--;
                    }
                    result[j+1] = tmp;
                  }
                  return result;
                }
              </pre>
            </div>
            <div class="sort-detail" id="s2">
              <strong>结果：</strong>
              <p id="s2-res"></p>
              <p>原理图：</p>
              <img alt="二分插入排序原理图" src="images/sort2.jpg" title="二分插入排序原理图"/>
              <p>二分插入排序</p>
              <pre class="brush:javascript">
                // 先在有序区通过二分查找的方法找到移动元素的起始位置，然后通过这个起始位置将后面所有的元素后移
                function sort2(array) {
                  var len = array.length,
                      i, j, tmp, low, high, mid, result;
                  // 赋予数组副本
                  result = array.slice(0);
                  for(i = 1; i < len; i++){
                    tmp = result[i];
                    low = 0;
                    high = i - 1;
                    while(low <= high){
                      mid = parseInt((low + high)/2, 10);
                      if(tmp < result[mid]) high = mid - 1;
                      else low = mid + 1;
                    }
                    for(j = i - 1; j >= high+1; j--){
                      result[j+1] = result[j];            
                    }
                    result[j+1] = tmp;
                  }
                  return result;
                }
              </pre>
            </div>
            <div class="sort-detail" id="s3">
              <strong>结果：</strong>
              <p id="s3-res"></p>
              <p>原理图：</p>
              <img alt="希尔排序原理图" src="images/sort3.jpg" title="希尔排序原理图"/>
              <p>希尔排序</p>
              <pre class="brush:javascript">
                // 希尔排序：先将整个待排序记录序列分割成若干个子序列，在在序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序
                function sort3(array){
                  var len = array.length, gap = parseInt(len/2), 
                      i, j, tmp, result;
                  // 复制数组
                  result = array.slice(0);
                  while(gap > 0){
                    for(i = gap; i < len; i++){
                      tmp = result[i];
                      j = i - gap;
                      while(j>=0 && tmp < result[j]){
                        result[j + gap] = result[j];
                        j = j - gap;
                      }
                      result[j + gap] = tmp;
                    }
                    gap = parseInt(gap/2);
                  }
                  return result;
                }
              </pre>
            </div>
            <div class="sort-detail" id="s4">
              <strong>结果：</strong>
              <p id="s4-res"></p>
              <p>冒泡排序</p>
              <pre class="brush:javascript">
                //
              </pre>
            </div>
            <div class="sort-detail" id="s5">
              <strong>结果：</strong>
              <p id="s5-res"></p>
              <p>改进冒泡排序</p>
              <pre class="brush:javascript">
                //
              </pre>
            </div>
            <div class="sort-detail" id="s6">
              <strong>结果：</strong>
              <p id="s6-res"></p>
              <p>快速排序</p>
              <pre class="brush:javascript">
                //
              </pre>
            </div>
            <div class="sort-detail" id="s7">
              <strong>结果：</strong>
              <p id="s7-res"></p>
              <p>选择排序</p>
              <pre class="brush:javascript">
                //
              </pre>
            </div>
            <div class="sort-detail" id="s8">
              <strong>结果：</strong>
              <p id="s8-res"></p>
              <p>堆排序</p>
              <pre class="brush:javascript">
                //
              </pre>
            </div>
            <div class="sort-detail" id="s9">
              <strong>结果：</strong>
              <p id="s9-res"></p>
              <p>归并排序</p>
              <pre class="brush:javascript">
                //
              </pre>
            </div>
          </div>

        </div>

        <script type="text/javascript" src="utils.js"></script>
        <script>
          // 全局变量命名空间
          var xq = {};
          // 测试以上函数 方便演示代码， 添加代码高亮插件
          xq.t_array = [4, 2, 5, 5, 8, 12, 43, 7, 2];
          xq.unique_fns = {};
          xq.sort_fns = {};
          xq.sort_array = [8,2, 3, 55, 12, 20, 16, 18, 15, 20, 11, 7];

          // 判断浏览器是否indexOf (indexOf 为ecmaScript5新方法 IE8以下（包括IE8）只支持到ECMAScript3)
          if (!Array.prototype.indexOf){
            // 新增indexOf方法
            Array.prototype.indexOf = function(item){
              var result = -1, a_item = null;
              if (this.length == 0){
                return result;
              }
              for(var i = 0, len = this.length; i < len; i++){
                a_item = this[i];
                if (a_item === item){
                  result = i;
                  break;
                }  
              }
              return result;
            }
          }
          init();

          function init(){
            var unique_btn, sort_btn, unique_panel, sort_panel,unique_radios, sort_radios;
            
            unique_btn = document.getElementById('uniqueBtn');
            sort_btn = document.getElementById('sortBtn');

            // 默认显示第一项
            showUniquePanel();
            unique_btn.onclick = showUniquePanel;
            sort_btn.onclick = showSortPanel;

            // raido 事件处理
            // unique_panel = document.getElementById('uniquePanel');
            // sort_panel = document.getElementById('sortPanel');
            unique_radios = document.getElementsByName('unique');
            sort_radios = document.getElementsByName('sort');

            // 初始化 数组函数
            initArrayFns();

            // 初始化 数组去重radio事件
            initRadios(unique_radios, 'un-detail');
            // 显示默认项
            showDetail('r5', 'un-detail');

            // 初始化 数组去重radio事件
            initRadios(sort_radios, 'sort-detail');
            // 显示默认项
            showDetail('s6', 'sort-detail');

            // 代码高亮显示
            SyntaxHighlighter.config.clipboardSwf = 'http://static.oschina.net/js/syntax-highlighter-2.1.382/scripts/clipboard.swf';
            SyntaxHighlighter.all();
          }

          function initArrayFns(){
            // 初始化去重函数
            xq.unique_fns['r1'] = unique1;
            xq.unique_fns['r2'] = unique2;
            xq.unique_fns['r3'] = unique3;
            xq.unique_fns['r4'] = unique4;
            xq.unique_fns['r5'] = unique5;
            // 初始化排序函数
            xq.sort_fns['s1'] = sort1;
            xq.sort_fns['s2'] = sort2;
            xq.sort_fns['s3'] = sort3;

          }
          function showUniquePanel(){
            showPanel('uniquePanel');
          }
          function showSortPanel(){
            showPanel('sortPanel');
          }
          function hideAllPanel(){
            var panel_list, i, len, p_item;
            panel_list = document.getElementsByClassName('panel');
            for (i = 0, len = panel_list.length; i < len; i++) {
              p_item = panel_list[i];
              p_item.style.display = 'none';
            }
          }
          function showPanel(p_id){
            var p_item; 
            hideAllPanel();
            p_item = document.getElementById(p_id);
            p_item.style.display = 'block';
          }

          // 初始化 radio按钮事件
          function initRadios(btn_list, p_class){
            var i, len, btn, b_id;

            for (i = 0, len = btn_list.length; i < len; i++) {
              btn = btn_list[i];
              btn.onclick = function(){
                var b_id = this.getAttribute('data-id');
                showDetail(b_id, p_class);
              }
            }
          }
          // 隐藏指定类型的所有详情面板
          function hideAllDetail(detail_list){
            var i , len, detail;
            if (!detail_list || detail_list.length == 0) {
              return false;
            }
            for (i = 0, len = detail_list.length; i < len; i++) {
              detail = detail_list[i];
              detail.style.display = 'none';
            }
          }
          // 显示某一详情面板
          function showDetail(u_id, p_class){
            var detail_list, show_detail, result, result_panel;
            if (!u_id) {
              return false;
            }
            detail_list = document.getElementsByClassName(p_class);
            show_detail = document.getElementById(u_id);
            hideAllDetail(detail_list);
            show_detail.style.display = 'block';
            if (p_class === 'un-detail' && (typeof xq.unique_fns[u_id]) === 'function') {
              // 执行对应函数
              result = xq.unique_fns[u_id](xq.t_array);
              // 结果显示在对应面板中
              result_panel = document.getElementById(u_id + '-res');
              result_panel.innerHTML = '';
              result_panel.appendChild(document.createTextNode(result));
            } else if (p_class === 'sort-detail' && (typeof xq.sort_fns[u_id]) === 'function'){
              // 执行对应函数
              result = xq.sort_fns[u_id](xq.sort_array);
              // 结果显示在对应面板中
              result_panel = document.getElementById(u_id + '-res');
              result_panel.innerHTML = '';
              result_panel.appendChild(document.createTextNode(result));
            }
          }

          // 最简单数组去重法
          function unique1(array){
            var n = []; //一个新的临时数组
            //遍历当前数组
            for(var i = 0; i < array.length; i++){
              //如果当前数组的第i已经保存进了临时数组，那么跳过，
              //否则把当前项push到临时数组里面
              if (n.indexOf(array[i]) == -1) n.push(array[i]);
            }
            return n;
          }

          // 速度最快， 占空间最多（空间换时间）
          function unique2(array){
            var n = {}, r = [], len = array.length, val, type;
              for (var i = 0; i < array.length; i++) {
                  val = array[i];
                  type = typeof val;
                  if (!n[val]) {
                      n[val] = [type];
                      r.push(val);
                  } else if (n[val].indexOf(type) < 0) {
                      n[val].push(type);
                      r.push(val);
                  }
              }
              return r;
          }

          function unique3(array){
            var n = [array[0]]; //结果数组
            //从第二项开始遍历
            for(var i = 1; i < array.length; i++) {
              //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
              //那么表示第i项是重复的，忽略掉。否则存入结果数组
              if (array.indexOf(array[i]) == i) n.push(array[i]);
            }
            return n;
          }

          // 将相同的值相邻，然后去除
          function unique4(array){
            array.sort(); 
            var re=[array[0]];
            for(var i = 1; i < array.length; i++){
              if( array[i] !== re[re.length-1])
              {
                re.push(array[i]);
              }
            }
            return re;
          }
          // 思路：获取没重复的最右一值放入新数组
          function unique5(array){
            var r = [];
            for(var i = 0, l = array.length; i < l; i++) {
              for(var j = i + 1; j < l; j++)
                if (array[i] === array[j]) j = ++i; 
              r.push(array[i]);
            }
            return r;
          }

          // 插入排序 从下标1开始每增1项排序一次，越往后遍历次数越多
          function sort1(array) {
            var len = array.length,
                i, j, tmp, result;

            // 赋予数组副本
            result = array.slice(0);
            for(i=1; i<len; i++){
              tmp = result[i];
              j = i - 1;
              while(j>=0 && tmp < result[j]){
                result[j+1] = result[j];
                j--;
              }
              result[j+1] = tmp;
            }
            return result;
          }
          // 先在有序区通过二分查找的方法找到移动元素的起始位置，然后通过这个起始位置将后面所有的元素后移
          // 关于二分查找排序，该贴子的图比较易懂http://www.cnblogs.com/liuling/p/2013-7-24-01.html
          function sort2(array) {
            var len = array.length,
                i, j, tmp, low, high, mid, result;
            // 赋予数组副本
            result = array.slice(0);
            for(i = 1; i < len; i++){
              tmp = result[i];
              low = 0;
              high = i - 1;
              while(low <= high){
                mid = parseInt((low + high)/2, 10);
                if(tmp < result[mid]) high = mid - 1;
                else low = mid + 1;
              }
              for(j = i - 1; j >= high+1; j--){
                result[j+1] = result[j];            
              }
              result[j+1] = tmp;
            }
            return result;
          }

          // 希尔排序：
          function sort3(array){
            var len = array.length, gap = parseInt(len/2), 
                i, j, tmp, result;
            // 复制数组
            result = array.slice(0);
            while(gap > 0){
              for(i = gap; i < len; i++){
                tmp = result[i];
                j = i - gap;
                while(j>=0 && tmp < result[j]){
                  result[j + gap] = result[j];
                  j = j - gap;
                }
                result[j + gap] = tmp;
              }
              gap = parseInt(gap/2);
            }
            return result;
          }
          
        </script>

    </body>
</html>